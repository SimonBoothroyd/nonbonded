import logging
import os
import shutil
import subprocess
from contextlib import contextmanager
from glob import glob
from typing import Optional

import click
from click_option_group import optgroup

from nonbonded.cli.utilities import generate_click_command
from nonbonded.library.factories.inputs.evaluator import EvaluatorServerConfig
from nonbonded.library.models.projects import Optimization
from nonbonded.library.models.targets import EvaluatorTarget

logger = logging.getLogger(__name__)


def _remove_previous_files():
    """Attempts to delete any files generated by a previous run."""

    restart_files = [
        "optimize.tmp",
        "optimize.bak",
        "optimize.sav",
        "result",
        "worker-logs",
        "working-data",
    ]

    for restart_file in restart_files:

        if os.path.isdir(restart_file):
            shutil.rmtree(restart_file)
        elif os.path.isfile(restart_file):
            os.unlink(restart_file)
        else:
            continue

        logger.info(f"Removing {restart_file}.")


def _prepare_restart(optimization: Optimization):
    """Attempts to prepare the directory structure for a restart."""

    all_targets_complete = True

    n_completed_iterations = 0
    restart_from_incomplete = False

    for iteration in range(optimization.max_iterations):

        iteration_string = "iter_" + str(iteration).zfill(4)

        # Determine if all target have completed for this iteration.
        targets_complete = all(
            [
                os.path.isfile(
                    os.path.join(
                        "optimize.tmp", target.id, iteration_string, "objective.p"
                    )
                )
                for target in optimization.targets
            ]
        )

        if targets_complete:

            n_completed_iterations += 1
            continue

        if any(
            not os.path.isdir(os.path.join("optimize.tmp", target.id, iteration_string))
            for target in optimization.targets
        ):
            break

        all_targets_complete = False

        # Given that the previous iteration completed, check whether there is enough
        # information to restart from this iteration. Namely, do the expected 'mvals.txt'
        # and 'force-field.offxml' files exist.
        restart_from_incomplete = all(
            all(
                os.path.isfile(
                    os.path.join("optimize.tmp", target.id, iteration_string, file_name)
                )
                for file_name in ["mvals.txt", "force-field.offxml"]
            )
            for target in optimization.targets
        )

        break

    all_targets_complete = n_completed_iterations > 0 and all_targets_complete

    restart_iteration = n_completed_iterations + (
        0 if restart_from_incomplete or all_targets_complete else -1
    )

    # Remove any directories which should not exist under normal circumstances.
    expected_directories = [
        os.path.join("optimize.tmp", target.id, "iter_" + str(iteration).zfill(4))
        for target in optimization.targets
        for iteration in range(restart_iteration + 1)
    ]

    found_directories = glob(os.path.join("optimize.tmp", "*", "iter_*"))

    for unexpected_directory in {*found_directories} - {*expected_directories}:

        logger.info(
            f"Removing the {unexpected_directory} directory which was not expected to "
            f"be present and may cause issues when restarting. This directory should "
            f"not have existed in normal circumstances."
        )
        shutil.rmtree(unexpected_directory)

    # Print a message to the user about any restart.
    if n_completed_iterations > 0 or restart_from_incomplete:

        logger.info(
            f"{n_completed_iterations} iterations had previously been completed. "
            f"The optimization will be restarted from iteration "
            f"{str(restart_iteration).zfill(4)}"
        )


@contextmanager
def _launch_required_services(optimization: Optimization, server_config: Optional[str]):
    """Launches any required services such as an OpenFF Evaluator server."""

    if not any(isinstance(target, EvaluatorTarget) for target in optimization.targets):
        yield
        return

    if server_config is None:

        raise RuntimeError(
            "The path to an OpenFF Evaluator server configuration must be provided "
            "when running an optimization against a physical property data set."
        )

    server_config = EvaluatorServerConfig.parse_file(server_config)

    # Disable data caching when re-weighting is disabled and the user hasn't
    # explicitly requested it.
    requires_cached_data = any(
        target.allow_reweighting
        for target in optimization.targets
        if isinstance(target, EvaluatorTarget)
    )

    if server_config.enable_data_caching is None:
        server_config.enable_data_caching = requires_cached_data

    calculation_backend = server_config.to_backend()

    with calculation_backend:

        evaluator_server = server_config.to_server(calculation_backend)

        with evaluator_server:

            yield


def _run_options():

    return [
        click.option(
            "--restart",
            default=False,
            type=click.BOOL,
            help="Whether to restart the optimization from where it left off.\nIf "
            "false any existing results will be removed / overwritten.",
            show_default=True,
        ),
        optgroup.group(
            "Evaluator configuration",
            help="Configuration options for the OpenFF Evaluator.",
        ),
        optgroup.option(
            "--config",
            "server_config",
            default="server-config.json",
            type=click.Path(exists=False, dir_okay=False),
            help="The path to the OpenFF Evaluator server configuration file.",
            show_default=True,
        ),
    ]


def run_command():
    def base_function(**kwargs):

        restart = kwargs.pop("restart")
        server_config = kwargs.pop("server_config")

        # Load in the optimization being performed.
        optimization = Optimization.parse_file("optimization.json")

        # Remove any residual files if not restarting.
        should_restart = False

        if not restart:
            _remove_previous_files()
        else:

            if not os.path.isfile("optimize.sav"):

                logger.info(
                    "No 'optimize.sav' file was found. It will be assumed that the "
                    "optimization should be started from the beginning."
                )
                _remove_previous_files()

            else:
                _prepare_restart(optimization)
                should_restart = True

        force_balance_arguments = ["ForceBalance.py", "optimize.in"]

        if should_restart:
            force_balance_arguments.insert(1, "--continue")

        with _launch_required_services(optimization, server_config):

            with open("force_balance.log", "w") as file:
                subprocess.check_call(force_balance_arguments, stderr=file, stdout=file)

    return generate_click_command(
        click.command(
            "run",
            help="Run a ForceBalance optimization in the current directory.\n\nThis "
            "directory must contain all of the required ForceBalance input files.",
        ),
        [*_run_options()],
        base_function,
    )
