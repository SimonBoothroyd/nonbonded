import pytest
from openff.recharge.conformers import ConformerSettings
from openff.recharge.esp import ESPSettings
from openff.recharge.grids import GridSettings

from nonbonded.library.models.targets import EvaluatorTarget, RechargeTarget
from nonbonded.library.templates.forcebalance import ForceBalanceInput
from nonbonded.library.utilities.exceptions import UnrecognisedKwargsError


def force_balance_expectation() -> str:

    return "\n".join(
        [
            "# ForceBalance input file generated by MakeInputFile.py",
            "# The octothorpe '#' is a comment symbol",
            "# Note: If the specified value is 'None' then the option will truly be set to None - not the string 'None'",
            "# Note: 'Section' option types are more complicated and may require you to read the documentation",
            "# Note: Boolean option types require no value, the key being present implies 'True'",
            "",
            "$options",
            "# (string) Directory containing force fields, relative to project directory",
            "ffdir forcefield",
            "",
            "# (string) Type of the penalty, L2 or L1 in the optimizer",
            "penalty_type L2",
            "",
            "# (allcap) The job type, defaults to a single-point evaluation of objective function",
            "jobtype optimize",
            "",
            "# (list) The names of force fields, corresponding to directory forcefields/file_name.(itp|gen)",
            "forcefield ff.offxml",
            "",
            "# (int) Maximum number of steps in an optimization",
            "maxstep 1",
            "",
            "# (float) Convergence criterion of step size (just needs to fall below this threshold)",
            "convergence_step 0.1",
            "",
            "# (float) Convergence criterion of objective function (in MainOptimizer this is the stdev of x2 over 10 steps)",
            "convergence_objective 0.2",
            "",
            "# (float) Convergence criterion of gradient norm",
            "convergence_gradient 0.3",
            "",
            "# The number of convergence criteria that must be met for main optimizer to converge",
            "criteria 4",
            "",
            "# (float) Minimum eigenvalue for applying steepest descent correction in the MainOptimizer",
            "eig_lowerbound 0.01",
            "",
            "# (float) Step size for finite difference derivatives in many functions (get_(G/H) in fitsim, FDCheckG)",
            "finite_difference_h 0.001",
            "",
            "# (float) Factor for multiplicative penalty function in objective function",
            "penalty_additive 1.0",
            "",
            "trust0 0.5",
            "mintrust 0.6",
            "error_tolerance 1.0",
            "adaptive_factor 0.2",
            "adaptive_damping 1.0",
            "normalize_weights no",
            "print_hessian",
            "",
            '# Charge constraints are taken care of using "evals".',
            "constrain_charge false",
            "",
            "priors",
            "   prior1 :  1.1",
            "   prior2 :  1.2",
            "/priors",
            "",
            "$end",
            "$target",
            "name evaluator-target-1",
            "type Evaluator_SMIRNOFF",
            "weight 0.7",
            "evaluator_input options.json",
            "$end",
            "$target",
            "name evaluator-target-2",
            "type Evaluator_SMIRNOFF",
            "weight 0.9",
            "evaluator_input options.json",
            "$end",
            "$target",
            "name recharge-target-1",
            "type Recharge_SMIRNOFF",
            "weight 0.8",
            "recharge_esp_store esp-store.sqlite",
            "recharge_property esp",
            "$end",
            "$target",
            "name recharge-target-2",
            "type Recharge_SMIRNOFF",
            "weight 1.0",
            "recharge_esp_store esp-store.sqlite",
            "recharge_property esp",
            "$end",
        ]
    )


def test_force_balance_template():

    content = ForceBalanceInput.generate(
        "ff.offxml",
        1,
        0.1,
        0.2,
        0.3,
        4,
        0.5,
        0.6,
        [
            EvaluatorTarget(
                id="evaluator-target-1",
                weight=0.7,
                data_set_ids=["data-set-1"],
                denominators={"Density": "1.0 * g / mL"},
            ),
            RechargeTarget(
                id="recharge-target-1",
                weight=0.8,
                molecule_set_ids=["molecule-set-1"],
                conformer_settings=ConformerSettings(),
                esp_settings=ESPSettings(grid_settings=GridSettings()),
                property="esp",
            ),
            EvaluatorTarget(
                id="evaluator-target-2",
                weight=0.9,
                data_set_ids=["data-set-1"],
                denominators={"Density": "1.0 * g / mL"},
            ),
            RechargeTarget(
                id="recharge-target-2",
                weight=1.0,
                molecule_set_ids=["molecule-set-1"],
                conformer_settings=ConformerSettings(),
                esp_settings=ESPSettings(grid_settings=GridSettings()),
                property="esp",
            ),
        ],
        {"prior1": 1.1, "prior2": 1.2},
    )

    assert content == force_balance_expectation()


def test_invalid_option():

    with pytest.raises(UnrecognisedKwargsError) as error_info:
        ForceBalanceInput.generate(
            "ff.offxml", 1, 0.1, 0.2, 0.3, 4, 0.5, 0.6, [], {}, invalid_kwarg_1=1
        )

    assert "invalid_kwarg_1" in error_info.value.kwarg_names
